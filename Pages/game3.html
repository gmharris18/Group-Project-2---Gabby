<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Robot Beeper Challenge</title>

    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../styles/main.css" />
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <style>
      .game-container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 10px;
        height: calc(100vh - 80px);
        overflow: hidden;
      }
      
      .game-row {
        display: flex;
        gap: 15px;
        align-items: flex-start;
        height: 100%;
      }
      
      .game-area {
        flex: 1;
        min-width: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      
      .left-panel {
        flex: 0 0 250px;
        max-width: 250px;
        height: 100%;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .controls {
        flex: 0 0 320px;
        max-width: 320px;
        height: 100%;
        overflow-y: auto;
      }
      
      .level-selector {
        background: #0d6efd;
        border: 2px solid #0b5ed7;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        color: white;
      }
      
      .level-buttons {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        gap: 20px;
        margin-top: 20px;
        max-width: 900px;
        margin-left: auto;
        margin-right: auto;
      }
      
      .level-buttons .level-btn:nth-child(1) {
        grid-column: 1 / span 2;
      }
      
      .level-buttons .level-btn:nth-child(2) {
        grid-column: 3 / span 2;
      }
      
      .level-buttons .level-btn:nth-child(3) {
        grid-column: 5 / span 2;
      }
      
      .level-buttons .level-btn:nth-child(4) {
        grid-column: 2 / span 2;
      }
      
      .level-buttons .level-btn:nth-child(5) {
        grid-column: 4 / span 2;
      }
      
      .level-btn {
        background: white;
        color: #0d6efd;
        border: 2px solid #dee2e6;
        border-radius: 12px;
        padding: 25px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
        text-align: left;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      
      .level-btn:hover {
        background: #e9ecef;
        color: #0d6efd;
        border-color: #0d6efd;
        transform: translateY(-2px);
      }
      
      .level-btn.active {
        background: #198754;
        color: white;
        border-color: #198754;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      }
      
      .level-title {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 8px;
      }
      
      .level-desc {
        font-size: 16px;
        opacity: 0.9;
        margin-bottom: 8px;
      }
      
      .level-difficulty {
        font-size: 14px;
        font-weight: bold;
        opacity: 0.8;
      }
      
      .game-area {
        background: #f8f9fa;
        border: 2px solid #dee2e6;
        border-radius: 12px;
        padding: 20px;
        text-align: center;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      
      .grid {
        display: inline-grid;
        grid-template-columns: repeat(8, 45px);
        grid-template-rows: repeat(8, 45px);
        gap: 2px;
        background: #212529;
        border: 3px solid #495057;
        border-radius: 8px;
        padding: 10px;
        margin: 20px 0;
        flex-shrink: 0;
      }
      
      .cell {
        width: 45px;
        height: 45px;
        background: #343a40;
        border: 1px solid #495057;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        border-radius: 4px;
      }
      
      .robot {
        width: 35px;
        height: 35px;
        background: #0d6efd;
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        color: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      }
      
      .beeper {
        width: 20px;
        height: 20px;
        background: #198754;
        border-radius: 50%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 14px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      }
      
      .controls {
        background: #f8f9fa;
        border: 2px solid #dee2e6;
        border-radius: 12px;
        padding: 15px;
      }
      
      .command-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 15px 0;
      }
      
      .cmd-btn {
        background: #0d6efd;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
        font-size: 14px;
      }
      
      .cmd-btn:hover {
        background: #0b5ed7;
        transform: translateY(-1px);
      }
      
      .cmd-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
        transform: none;
      }
      
      .code-area {
        background: #212529;
        border: 2px solid #495057;
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        min-height: 200px;
        font-family: 'Courier New', monospace;
        color: #f8f9fa;
        overflow-y: auto;
        max-height: 250px;
        font-size: 14px;
      }
      
      .code-line {
        margin: 6px 0;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .code-line:hover {
        background: rgba(13, 110, 253, 0.1);
      }
      
      .code-line.selected {
        background: rgba(13, 110, 253, 0.2);
      }
      
      .left-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 15px;
      }
      
      .right-buttons {
        display: flex;
        flex-direction: row;
        gap: 10px;
        margin-top: 15px;
      }
      
      .game-btn {
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
        font-size: 14px;
      }
      
      .game-btn.primary {
        background: #198754;
        color: white;
      }
      
      .game-btn.primary:hover {
        background: #157347;
      }
      
      .game-btn.danger {
        background: #dc3545;
        color: white;
      }
      
      .game-btn.danger:hover {
        background: #bb2d3b;
      }
      
      .game-btn.secondary {
        background: #6c757d;
        color: white;
      }
      
      .game-btn.secondary:hover {
        background: #5c636a;
      }
      
      .stats {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 15px;
        background: #e9ecef;
        border-radius: 8px;
        flex-shrink: 0;
      }
      
      .stat {
        text-align: center;
        padding: 8px;
        background: white;
        border-radius: 6px;
      }
      
      .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #0d6efd;
      }
      
      .stat-label {
        font-size: 12px;
        color: #6c757d;
        margin-top: 5px;
      }
      
      .back-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      
      .left-panel-btn {
        background: #f8f9fa;
        border: 2px solid #dee2e6;
        border-radius: 12px;
        padding: 15px;
      }
    </style>
  </head>
  <body>
    <!-- Back Button -->
    <div class="container">
      <div class="d-flex justify-content-end pt-3">
        <a href="./game.html" class="btn btn-outline-primary">
          ‚Üê Back to Games
        </a>
      </div>
    </div>


    <!-- Main Content -->
    <div class="game-container">
      <!-- Level Selector -->
      <div class="level-selector">
        <div class="text-center">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-3">Loading your progress...</p>
        </div>
      </div>

      <div id="gameContent" style="display: none;">
        <div class="game-row">
          <!-- Left Panel -->
          <div class="left-panel">
            <div class="left-panel-btn">
              <div class="left-buttons">
                <button class="game-btn danger" id="resetBtn">üîÑ Reset Level</button>
                <button class="game-btn secondary" id="backBtn" onclick="backToLevelSelect()">‚Üê Back to Levels</button>
              </div>
            </div>
            
            <div class="stats">
              <div class="stat">
                <div class="stat-value" id="beepersCollected">0</div>
                <div class="stat-label">Beepers Collected</div>
              </div>
              <div class="stat">
                <div class="stat-value" id="movesUsed">0</div>
                <div class="stat-label">Moves Used</div>
              </div>
              <div class="stat">
                <div class="stat-value" id="beepersRemaining">3</div>
                <div class="stat-label">Beepers Left</div>
              </div>
            </div>
          </div>
          
          <!-- Game Area (Center) -->
          <div class="game-area">
            <h3>ü§ñ Robot Beeper Challenge</h3>
            <p>Program the robot to collect all beepers (green dots) on the grid!</p>
            
            <div class="grid" id="gameGrid">
              <!-- Grid cells will be generated by JavaScript -->
            </div>
          </div>
          
          <!-- Controls (Right) -->
          <div class="controls">
            <h4>üéÆ Programming Commands</h4>
            <p class="small">Click commands to add them to your program:</p>
            
            <div class="command-buttons">
              <button class="cmd-btn" data-command="move">‚¨ÜÔ∏è Move Forward</button>
              <button class="cmd-btn" data-command="turnLeft">‚Ü©Ô∏è Turn Left</button>
              <button class="cmd-btn" data-command="turnRight">‚Ü™Ô∏è Turn Right</button>
              <button class="cmd-btn" data-command="pickBeeper">ü§ñ Pick Beeper</button>
              <button class="cmd-btn" data-command="putBeeper">üì¶ Put Beeper</button>
              <button class="cmd-btn" data-command="turnAround">üîÑ Turn Around</button>
            </div>
            
            <h5>üìù Your Program:</h5>
            <div class="code-area" id="codeArea">
              <div class="code-line" style="color: #6c757d;">Click commands above to build your program...</div>
            </div>
            
            <div class="right-buttons">
              <button class="game-btn primary" id="runBtn">‚ñ∂Ô∏è Run</button>
              <button class="game-btn secondary" id="clearBtn">üóëÔ∏è Clear</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap JS bundle -->
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>

    <!-- Custom JS -->
    <script src="../scripts/main.js"></script>
    <script src="../scripts/auth.js"></script>
    <script src="../scripts/gameProgress.js"></script>
    
    <script>
      // Notification utility function to replace alerts
      function showNotification(message, type = 'info') {
        // Remove any existing notifications
        const existingNotification = document.getElementById('notification');
        if (existingNotification) {
          existingNotification.remove();
        }

        // Create notification element
        const notification = document.createElement('div');
        notification.id = 'notification';
        notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
        notification.style.cssText = `
          top: 20px;
          right: 20px;
          z-index: 9999;
          min-width: 300px;
          max-width: 500px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        `;
        
        notification.innerHTML = `
          ${message}
          <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
          if (notification && notification.parentNode) {
            notification.remove();
          }
        }, 5000);
      }

      // Game state
      let currentLevel = 1;
      let robot = { x: 0, y: 0, direction: 0 }; // 0=East, 1=South, 2=West, 3=North
      let beepers = [];
      let obstacles = [];
      let collectedBeepers = 0;
      let movesUsed = 0;
      let isRunning = false;
      let program = [];
      let timeLimit = 0;
      let timeLeft = 0;
      let gameTimer = null;

      // Difficulty scores and completion tracking
      const difficultyScores = {
        1: 10,  // Easy
        2: 20,  // Medium
        3: 30,  // Hard
        4: 40,  // Extreme
        5: 50   // Master
      };

      let completedLevels = new Set(); // Track which levels have been completed

      // Level configurations
      const levels = {
        1: {
          name: "Easy",
          beepers: [{ x: 2, y: 1 }, { x: 5, y: 3 }, { x: 1, y: 6 }],
          obstacles: [],
          timeLimit: 0,
          description: "Simple 3-beeper collection"
        },
        2: {
          name: "Medium", 
          beepers: [{ x: 1, y: 2 }, { x: 3, y: 1 }, { x: 5, y: 4 }, { x: 2, y: 6 }, { x: 6, y: 2 }],
          obstacles: [{ x: 3, y: 3 }, { x: 4, y: 4 }],
          timeLimit: 0,
          description: "5 beepers with obstacles"
        },
        3: {
          name: "Hard",
          beepers: [{ x: 7, y: 1 }, { x: 1, y: 7 }, { x: 6, y: 6 }, { x: 2, y: 3 }, { x: 5, y: 1 }],
          obstacles: [{ x: 2, y: 2 }, { x: 3, y: 2 }, { x: 4, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }],
          timeLimit: 0,
          description: "Complex maze navigation"
        },
        4: {
          name: "Extreme",
          beepers: [{ x: 1, y: 1 }, { x: 6, y: 1 }, { x: 1, y: 6 }, { x: 6, y: 6 }, { x: 3, y: 3 }],
          obstacles: [{ x: 2, y: 2 }, { x: 4, y: 2 }, { x: 2, y: 4 }, { x: 4, y: 4 }],
          timeLimit: 30,
          description: "Time-limited beeper hunt"
        },
        5: {
          name: "Master",
          beepers: [{ x: 7, y: 0 }, { x: 0, y: 7 }, { x: 7, y: 7 }, { x: 0, y: 0 }, { x: 3, y: 3 }, { x: 4, y: 4 }],
          obstacles: [{ x: 1, y: 1 }, { x: 2, y: 2 }, { x: 5, y: 5 }, { x: 6, y: 6 }, { x: 3, y: 1 }, { x: 4, y: 2 }],
          timeLimit: 45,
          description: "Ultimate programming test"
        }
      };

      // Load completed levels from user progress
      async function loadCompletedLevels() {
        try {
          if (window.GameProgress) {
            const progress = await window.GameProgress.getGameProgress(3);
            if (progress && progress > 0) {
              // Calculate which levels are completed based on score
              let score = progress;
              const sortedLevels = Object.entries(difficultyScores).sort((a, b) => a[0] - b[0]);
              
              for (const [level, levelScore] of sortedLevels) {
                if (score >= levelScore) {
                  completedLevels.add(parseInt(level));
                  score -= levelScore;
                } else {
                  break;
                }
              }
            }
          }
          updateLevelButtons();
        } catch (error) {
          console.error('Error loading completed levels:', error);
        }
      }

      // Update level buttons to show completion status
      function updateLevelButtons() {
        const levelButtons = document.querySelectorAll('.level-btn');
        levelButtons.forEach(button => {
          const level = parseInt(button.dataset.level);
          const isCompleted = completedLevels.has(level);
          
          if (isCompleted) {
            button.classList.add('completed');
            button.innerHTML = `
              <div class="level-title">${levels[level].name} ‚úÖ</div>
              <div class="level-desc">${levels[level].description}</div>
              <div class="level-difficulty">Completed!</div>
            `;
            button.style.background = '#198754';
            button.style.color = 'white';
            button.style.borderColor = '#198754';
          } else {
            button.classList.remove('completed');
            const emoji = ['üå±', '‚ö°', 'üî•', 'üöÄ', 'üèÜ'][level - 1];
            button.innerHTML = `
              <div class="level-title">${emoji} ${levels[level].name}</div>
              <div class="level-desc">${levels[level].description}</div>
              <div class="level-difficulty">${getDifficultyText(level)}</div>
            `;
            button.style.background = 'white';
            button.style.color = '#0d6efd';
            button.style.borderColor = '#dee2e6';
          }
        });
      }

      // Get difficulty text for display
      function getDifficultyText(level) {
        const texts = ['Beginner Friendly', 'Strategic Thinking', 'Expert Level', 'Speed Challenge', 'Legendary'];
        return texts[level - 1] || 'Challenge';
      }

      // Show completion popup
      async function showCompletionPopup() {
        // Calculate scores
        const currentUserScore = await getCurrentUserScore();
        const newTotalScore = calculateTotalScore();
        const scoreEarned = Math.max(0, newTotalScore - currentUserScore);
        
        // Create popup overlay
        const popup = document.createElement('div');
        popup.id = 'completionPopup';
        popup.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9999;
          backdrop-filter: blur(5px);
        `;
        
        const difficultyName = levels[currentLevel].name;
        const nextLevel = currentLevel < 5 ? currentLevel + 1 : null;
        
        popup.innerHTML = `
          <div class="card shadow-lg" style="max-width: 500px; width: 90%;">
            <div class="card-body text-center p-5">
              <div class="mb-4">
                <i class="fas fa-check-circle text-success" style="font-size: 4rem;"></i>
              </div>
              <h2 class="mb-3 text-success">${difficultyName} Complete!</h2>
              <p class="mb-4 fs-5">Score earned: <strong class="text-primary">${scoreEarned}</strong></p>
              
              <div class="d-grid gap-3">
                <button class="btn btn-outline-primary btn-lg" onclick="closeCompletionPopup('levelSelect')">
                  Level Selection
                </button>
                <button class="btn btn-outline-secondary btn-lg" onclick="closeCompletionPopup('tryAgain')">
                  Try Again
                </button>
                ${nextLevel ? `
                <button class="btn btn-primary btn-lg" onclick="closeCompletionPopup('nextLevel')">
                  Next Level
                </button>
                ` : ''}
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(popup);
      }
      
      // Close completion popup and handle action
      async function closeCompletionPopup(action) {
        // Remove popup
        const popup = document.getElementById('completionPopup');
        if (popup) {
          popup.remove();
        }
        
        // Save score if higher than current
        await saveLevelProgress();
        
        // Handle action
        switch (action) {
          case 'levelSelect':
            // Hide game content and show level selector
            document.getElementById('gameContent').style.display = 'none';
            document.querySelector('.level-selector').style.display = 'block';
            break;
          case 'tryAgain':
            // Reset current level
            loadLevel(currentLevel);
            break;
          case 'nextLevel':
            if (currentLevel < 5) {
              loadLevel(currentLevel + 1);
            }
            break;
        }
      }
      
      // Get current user's score from API
      async function getCurrentUserScore() {
        try {
          if (window.GameProgress) {
            const progress = await window.GameProgress.getGameProgress(3);
            return progress || 0;
          }
          return 0;
        } catch (error) {
          console.error('Error getting current user score:', error);
          return 0;
        }
      }
      
      // Calculate total score if current level is completed
      function calculateTotalScore() {
        // If current level is completed, all levels 1 through currentLevel are completed
        let totalScore = 0;
        
        for (let level = 1; level <= currentLevel; level++) {
          const levelScore = difficultyScores[level];
          totalScore += levelScore;
        }
        
        return totalScore;
      }
      
      // Save level progress
      async function saveLevelProgress() {
        try {
          // Mark this level AND all lower levels as completed
          for (let level = 1; level <= currentLevel; level++) {
            completedLevels.add(level);
          }
          
          // Calculate cumulative score: current difficulty score + all previous difficulty scores
          let totalScore = 0;
          for (let level = 1; level <= currentLevel; level++) {
            totalScore += difficultyScores[level];
          }
          
          // Save progress directly (no login check needed - user is already logged in if they can access this page)
          const success = await window.GameProgress.saveGameProgress(3, totalScore);
          
          if (success) {
            // Update the level buttons to show completion status
            updateLevelButtons();
          } else {
            console.error('Failed to save level progress');
          }
        } catch (error) {
          console.error('Error saving level progress:', error);
        }
      }

      // Initialize game
      function initGame() {
        createGrid();
        updateDisplay();
      }

      function loadLevel(levelNum) {
        currentLevel = levelNum;
        const level = levels[levelNum];
        
        robot = { x: 0, y: 0, direction: 0 };
        beepers = [...level.beepers];
        obstacles = [...level.obstacles];
        collectedBeepers = 0;
        movesUsed = 0;
        isRunning = false;
        program = [];
        timeLimit = level.timeLimit;
        timeLeft = timeLimit;
        
        // Show game content
        document.getElementById('gameContent').style.display = 'block';
        document.querySelector('.level-selector').style.display = 'none';
        
        // Update level title
        document.querySelector('.game-area h3').textContent = `ü§ñ Level ${levelNum}: ${level.name}`;
        document.querySelector('.game-area p').textContent = level.description;
        
        // Ensure grid is created and display is updated
        createGrid();
        updateDisplay();
        updateCodeDisplay();
        
        // Start timer if needed
        if (timeLimit > 0) {
          startTimer();
        }
      }

      function startTimer() {
        if (gameTimer) clearInterval(gameTimer);
        timeLeft = timeLimit;
        gameTimer = setInterval(() => {
          timeLeft--;
          updateTimerDisplay();
          if (timeLeft <= 0) {
            clearInterval(gameTimer);
            showNotification('‚è∞ Time\'s up! Try again!', 'warning');
            resetGame();
          }
        }, 1000);
      }

      function updateTimerDisplay() {
        const timerEl = document.getElementById('timer');
        if (timerEl) {
          timerEl.textContent = `‚è±Ô∏è ${timeLeft}s`;
        }
      }

      function createGrid() {
        const grid = document.getElementById('gameGrid');
        grid.innerHTML = '';
        
        for (let y = 0; y < 8; y++) {
          for (let x = 0; x < 8; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.x = x;
            cell.dataset.y = y;
            grid.appendChild(cell);
          }
        }
      }

      function updateDisplay() {
        // Clear all cells
        document.querySelectorAll('.cell').forEach(cell => {
          cell.innerHTML = '';
        });

        // Place robot
        const robotCell = document.querySelector(`[data-x="${robot.x}"][data-y="${robot.y}"]`);
        if (robotCell) {
          const robotEl = document.createElement('div');
          robotEl.className = 'robot';
          robotEl.textContent = 'ü§ñ';
          robotEl.style.transform = `rotate(${robot.direction * 90}deg)`;
          robotCell.appendChild(robotEl);
        }

        // Place obstacles
        obstacles.forEach(obstacle => {
          const obstacleCell = document.querySelector(`[data-x="${obstacle.x}"][data-y="${obstacle.y}"]`);
          if (obstacleCell) {
            const obstacleEl = document.createElement('div');
            obstacleEl.className = 'obstacle';
            obstacleEl.textContent = '‚¨õ';
            obstacleEl.style.background = '#dc3545';
            obstacleEl.style.borderRadius = '4px';
            obstacleEl.style.color = 'white';
            obstacleEl.style.fontSize = '20px';
            obstacleCell.appendChild(obstacleEl);
          }
        });

        // Place beepers
        beepers.forEach(beeper => {
          const beeperCell = document.querySelector(`[data-x="${beeper.x}"][data-y="${beeper.y}"]`);
          if (beeperCell) {
            const beeperEl = document.createElement('div');
            beeperEl.className = 'beeper';
            beeperEl.textContent = '‚óè';
            beeperCell.appendChild(beeperEl);
          }
        });

        // Update stats
        document.getElementById('beepersCollected').textContent = collectedBeepers;
        document.getElementById('movesUsed').textContent = movesUsed;
        document.getElementById('beepersRemaining').textContent = beepers.length;
      }

      function addCommand(command) {
        if (isRunning) return;
        
        program.push(command);
        updateCodeDisplay();
      }

      function updateCodeDisplay() {
        const codeArea = document.getElementById('codeArea');
        codeArea.innerHTML = '';
        
        if (program.length === 0) {
          codeArea.innerHTML = '<div class="code-line" style="color: #6c757d;">Click commands above to build your program...</div>';
          return;
        }

        program.forEach((cmd, index) => {
          const line = document.createElement('div');
          line.className = 'code-line';
          line.textContent = `${index + 1}. ${getCommandText(cmd)}`;
          line.dataset.index = index;
          line.addEventListener('click', () => removeCommand(index));
          codeArea.appendChild(line);
        });
      }

      function getCommandText(command) {
        const texts = {
          move: '‚¨ÜÔ∏è Move Forward',
          turnLeft: '‚Ü©Ô∏è Turn Left',
          turnRight: '‚Ü™Ô∏è Turn Right',
          pickBeeper: 'ü§ñ Pick Beeper',
          putBeeper: 'üì¶ Put Beeper',
          turnAround: 'üîÑ Turn Around'
        };
        return texts[command] || command;
      }

      function removeCommand(index) {
        if (isRunning) return;
        program.splice(index, 1);
        updateCodeDisplay();
      }

      async function runProgram() {
        if (isRunning || program.length === 0) return;
        
        isRunning = true;
        document.getElementById('runBtn').textContent = '‚è∏Ô∏è Running...';
        document.getElementById('runBtn').disabled = true;

        for (let i = 0; i < program.length; i++) {
          const command = program[i];
          await executeCommand(command);
          await new Promise(resolve => setTimeout(resolve, 800)); // Animation delay
          
          if (beepers.length === 0) {
            // Show completion popup instead of alert
            await showCompletionPopup();
            break;
          }
        }

        isRunning = false;
        document.getElementById('runBtn').textContent = '‚ñ∂Ô∏è Run';
        document.getElementById('runBtn').disabled = false;
        
        // Clear the code input after any program execution
        program = [];
        updateCodeDisplay();
      }

      async function executeCommand(command) {
        switch (command) {
          case 'move':
            const newPos = getNewPosition(robot.x, robot.y, robot.direction);
            if (isValidPosition(newPos.x, newPos.y)) {
              robot.x = newPos.x;
              robot.y = newPos.y;
              movesUsed++;
            }
            break;
          case 'turnLeft':
            robot.direction = (robot.direction + 3) % 4;
            movesUsed++;
            break;
          case 'turnRight':
            robot.direction = (robot.direction + 1) % 4;
            movesUsed++;
            break;
          case 'turnAround':
            robot.direction = (robot.direction + 2) % 4;
            movesUsed++;
            break;
          case 'pickBeeper':
            const beeperIndex = beepers.findIndex(b => b.x === robot.x && b.y === robot.y);
            if (beeperIndex !== -1) {
              beepers.splice(beeperIndex, 1);
              collectedBeepers++;
            }
            break;
          case 'putBeeper':
            if (collectedBeepers > 0) {
              beepers.push({ x: robot.x, y: robot.y });
              collectedBeepers--;
            }
            break;
        }
        updateDisplay();
      }

      function getNewPosition(x, y, direction) {
        const directions = [
          { x: 1, y: 0 },  // East
          { x: 0, y: 1 },  // South
          { x: -1, y: 0 }, // West
          { x: 0, y: -1 }  // North
        ];
        const dir = directions[direction];
        return { x: x + dir.x, y: y + dir.y };
      }

      function isValidPosition(x, y) {
        return x >= 0 && x < 8 && y >= 0 && y < 8;
      }

      function resetGame() {
        if (gameTimer) {
          clearInterval(gameTimer);
          gameTimer = null;
        }
        loadLevel(currentLevel);
      }

      function backToLevelSelect() {
        document.getElementById('gameContent').style.display = 'none';
        document.querySelector('.level-selector').style.display = 'block';
        if (gameTimer) {
          clearInterval(gameTimer);
          gameTimer = null;
        }
      }

      function clearCode() {
        if (isRunning) return;
        program = [];
        updateCodeDisplay();
        // Visual feedback
        const clearBtn = document.getElementById('clearBtn');
        const originalText = clearBtn.textContent;
        clearBtn.textContent = '‚úÖ Cleared!';
        clearBtn.style.background = '#198754';
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.style.background = '#6c757d';
        }, 1000);
      }


      // Event listeners
      document.addEventListener('DOMContentLoaded', async () => {
        const levelSelector = document.querySelector('.level-selector');
        
        try {
          // Initialize game components first
          initGame();
          
          // Load completed levels from API before showing interface
          await loadCompletedLevels();
          
          // Show the level selector with buttons
          if (levelSelector) {
            levelSelector.innerHTML = `
              <h3>üéØ Choose Your Challenge</h3>
              <p>Select a difficulty level to start programming your robot!</p>
              
              <div class="level-buttons" id="levelButtons">
                <button class="level-btn" data-level="1">
                  <div class="level-title">üå± Easy</div>
                  <div class="level-desc">Simple 3-beeper collection</div>
                  <div class="level-difficulty">Beginner Friendly</div>
                </button>
                <button class="level-btn" data-level="2">
                  <div class="level-title">‚ö° Medium</div>
                  <div class="level-desc">5 beepers with obstacles</div>
                  <div class="level-difficulty">Strategic Thinking</div>
                </button>
                <button class="level-btn" data-level="3">
                  <div class="level-title">üî• Hard</div>
                  <div class="level-desc">Complex maze navigation</div>
                  <div class="level-difficulty">Expert Level</div>
                </button>
                <button class="level-btn" data-level="4">
                  <div class="level-title">üöÄ Extreme</div>
                  <div class="level-desc">Time-limited beeper hunt</div>
                  <div class="level-difficulty">Speed Challenge</div>
                </button>
                <button class="level-btn" data-level="5">
                  <div class="level-title">üèÜ Master</div>
                  <div class="level-desc">Ultimate programming test</div>
                  <div class="level-difficulty">Legendary</div>
                </button>
              </div>
            `;
          }
          
          // Update level buttons to show completion status
          updateLevelButtons();
          
          // Set up event listeners after content is loaded
          document.querySelectorAll('.level-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
              btn.classList.add('active');
              loadLevel(parseInt(btn.dataset.level));
            });
          });
          
          // Command buttons
          document.querySelectorAll('.cmd-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              addCommand(btn.dataset.command);
            });
          });

          // Game buttons - use event delegation to handle dynamically created elements
          document.addEventListener('click', (e) => {
            if (e.target.id === 'runBtn') {
              runProgram();
            } else if (e.target.id === 'resetBtn') {
              resetGame();
            } else if (e.target.id === 'clearBtn') {
              clearCode();
            }
          });
          
        } catch (error) {
          console.error('Error initializing game:', error);
          // Show error state
          if (levelSelector) {
            levelSelector.innerHTML = `
              <div class="text-center">
                <div class="alert alert-danger">
                  <h4>Error Loading Game</h4>
                  <p>There was an error loading your progress. Please refresh the page.</p>
                  <button class="btn btn-primary" onclick="location.reload()">Refresh Page</button>
                </div>
              </div>
            `;
          }
        }
      });

    </script>
  </body>
</html>
